generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===== ENUMS =====
enum UserRole {
  ADMIN
  EMPLOYEE
}

enum EmployeeLevel {
  TRAINEE
  RUNNER
  INTERMEDIATE
  EXPERT
}

enum EmployeePosition {
  SERVER
  BARTENDER
  SHIFT_MANAGER
}

enum ShiftType {
  LUNCH   // 11:00-17:00
  DINNER  // 17:00-23:00
}

enum ShiftRequestStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

// ===== MODELS =====

model User {
  id                String            @id @default(cuid())
  phone             String            @unique
  fullName          String
  password          String?
  role              UserRole          @default(EMPLOYEE)
  level             EmployeeLevel     @default(TRAINEE)
  position          EmployeePosition  @default(SERVER)
  isActive          Boolean           @default(true)
  registrationToken String?           @unique
  tokenUsed         Boolean           @default(false)
  pushToken         String?
  refreshTokens     RefreshToken[]

  // Relations
  availability      Availability[]
  assignedShifts    Shift[]           @relation("EmployeeShifts")
  managedShifts     Shift[]           @relation("ShiftManager")
  swapRequests      SwapRequest[]     @relation("RequestedBy")
  swapOffers        SwapRequest[]     @relation("AcceptedBy")
  swapApprovals     SwapRequest[]     @relation("ApprovedBy")
  notifications     Notification[]
  pushSubscriptions PushSubscription[]

  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  deletedAt         DateTime?
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model WeeklySchedule {
  id                String            @id @default(cuid())
  weekStartDate     DateTime
  weekEndDate       DateTime
  isPublished       Boolean           @default(false)
  publishedAt       DateTime?
  publishedBy       String?

  // Settings for required staff
  requiredStaff     Json              // {"lunch": 8, "dinner": 12}

  // Relations
  shifts            Shift[]
  availability      Availability[]

  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  @@unique([weekStartDate, weekEndDate])
}

model Shift {
  id                String            @id @default(cuid())
  date              DateTime
  type              ShiftType
  startTime         String            @default("11:00") // HH:mm format
  endTime           String            @default("16:00") // HH:mm format
  minimumStaff      Int               @default(6)

  // Relations
  schedule          WeeklySchedule    @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  scheduleId        String

  employees         User[]            @relation("EmployeeShifts")
  shiftManager      User?             @relation("ShiftManager", fields: [shiftManagerId], references: [id])
  shiftManagerId    String?

  swapRequests      SwapRequest[]

  // Quality metrics
  qualityScore      Int               @default(0) // 0-100
  isBalanced        Boolean           @default(false)

  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  @@unique([date, type])
  @@index([scheduleId])
}

model Availability {
  id                String            @id @default(cuid())

  // Relations
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String

  schedule          WeeklySchedule?   @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  scheduleId        String?

  // New fields for weekly availability
  week              DateTime          // Start of week
  dayOfWeek         Int               // 0=Sunday, 6=Saturday
  shiftType         ShiftType         // LUNCH or DINNER

  // Availability slots - JSON array (keeping for backward compatibility)
  // [{"day": "sunday", "lunch": true, "dinner": false}, ...]
  slots             Json?

  submittedAt       DateTime          @default(now())
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  @@unique([userId, week, dayOfWeek, shiftType])
  @@index([userId, week])
  @@index([scheduleId])
}

model SwapRequest {
  id                String            @id @default(cuid())

  // Relations
  shift             Shift             @relation(fields: [shiftId], references: [id], onDelete: Cascade)
  shiftId           String

  requestedBy       User              @relation("RequestedBy", fields: [requestedById], references: [id])
  requestedById     String

  acceptedBy        User?             @relation("AcceptedBy", fields: [acceptedById], references: [id])
  acceptedById      String?

  // Manager approval fields
  approvedBy        User?             @relation("ApprovedBy", fields: [approvedById], references: [id])
  approvedById      String?
  approvalNote      String?
  approvedAt        DateTime?

  status            ShiftRequestStatus @default(PENDING)
  reason            String?

  createdAt         DateTime          @default(now())
  resolvedAt        DateTime?

  @@index([shiftId])
  @@index([requestedById])
  @@index([status])
}

model Notification {
  id                String            @id @default(cuid())

  // Relations
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String

  type              String            // SHIFT_PUBLISHED, SWAP_REQUEST, REMINDER, etc.
  title             String
  message           String
  data              Json?

  isRead            Boolean           @default(false)
  readAt            DateTime?

  createdAt         DateTime          @default(now())

  @@index([userId, isRead])
}

// ===== PUSH NOTIFICATIONS =====
model PushSubscription {
  id                String            @id @default(cuid())

  // Relations
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String

  endpoint          String
  keys              Json              // Contains p256dh and auth keys
  expirationTime    DateTime?

  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  @@unique([userId, endpoint])
  @@index([userId])
}

// ===== SETTINGS =====
model SystemSettings {
  id                String            @id @default(cuid())
  key               String            @unique
  value             Json

  updatedAt         DateTime          @updatedAt
}